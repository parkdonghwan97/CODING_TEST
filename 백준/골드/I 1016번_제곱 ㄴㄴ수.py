

# I 1016번_제곱 ㄴㄴ수    쉬워보여서 깝쳤다가 머리꺠졌네

# 제곱 ㄴㄴ수 :  어떤 정수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때    

# 시간초과

# n,m  = map(int,input().split()) 

# cnt = 0
# for i in range(n,m+1):
#     for j in range(2,i+2):
#         if pow(j,2) > i :
#             cnt+=1
#             break

        
#         if i%pow(j,2) ==0:
#             break
# print(cnt)



# 답을 찾아보니 에라토스테네스의 체를 활용해야하더라

# 소수인 것을 찾고 그것들의 배수들에는 모두 소수가 아니라는 표기를 해서 걸러내는 알고리즘

'''
범위 내의 수들 제곱수로 나눠 떨어지는지, 즉 제곱수의 배수인지 조사 후 
카운트를 한다. 이미 개수에 넣은 수가 또 나오면 중복이 되므로
리스트를 만들어 이미 카운트한 수는 True값을 할당하는 방식으로 알고리즘을 짬


'''
# n,m = map(int,input().split())  # 최소값 최대값 받고
# a = m-n+1  # a값에 범위 내에 포함되는 수의 개수를 넣고 제곱수의 배수의 개수를 a에서 뺄거임


# # 범위가 만약 32부터 36인경우 divisibleByTheSquare[0],divisibleByTheSquare[1]은 각각 32와 33을 가리킴

# # False는 제곱의 배수가 아닌 수라면 True로 바뀌는 수는 제곱의 배수다.
# divisibleByTheSquare = [False] * (max-min+1)

# # 에라토스테네스의 체에서처럼 나눌 수는 2의 제곱부터 int(max**0.5)의 제곱까지만 고려하면 된다.
# for i in range(2, int(max**0.5+1)):
#     square = i**2


#     #  제곱수인 4,9, 16같은 것들이 범위 내의 수를 나누어 떨어지게 하면
#     # 그 수에 해당하는 인덱스를 True값으로 바꿈

#     # 이 때 범위를 (((min-1)//sqare)+1), max+1,square 인 이유는
#     # min이상의 가장 작은 square 배수부터 square만큼 커지는 수만 계산하기 위함.
#     #가장 밖의 for문을 다 돌게 되면 answer에서 제곱으로 나누어 떨어지는 수의 총 개수만큼 빼진다.
#     for j in range((((min-1)//square)+1)*square, max+1, square):
#       if not divisibleByTheSquare[j-min] : 		#해당 인덱스 값이 False라면
#                   divisibleByTheSquare[j-min] = True 	#True 바꿔준 뒤
#                   a -= 1 				#answer에서 1을 빼줌
 	#다음 반복에서는 나뉘어 떨어지더라도 이미 TRUE이기 때문에 answer에서 1이 빼지지 않음.

# 음 따라가질 못하겠네 .
# 이 문제의 핵심은 에라토스테네스의 체를 이용하는 것, 인덱스와 제곱 수의 관계를 이해

'''
에라토스테네스는 1부터 n이하의 수에서 소수들을 구해주는 알고리즘 
근데 위 알고리즘으로도 시간초과가 나니까 변형이 필요
10, 23 인경우 square = [4,9,16] 즉 2이상 root(MAX)이하의 제곱수로 이뤄진리스트
제곱수의 배수인 수는 모두 없애야함.

0부터가 아니기때문에 인덱스 0에 10을 저장하고 인덱스 1에는 11을 저장함.
인덱스 k일때 실제 수는 10+k이다. 
즉 정답을 저장하는 배열의 인덱스가 k라면 실제값은 MIN +k 이다. 
이제 12 16 18 20과 같은 수는 배열에서 제외해야하고.

12 18 16은 4 9 16의 배수 중 가장 작은 수
10을 각각 4 9 16으로 나눈 결과 2.5, 1.111, 0.625이다.
여기서 나머지들을 버리고 몫만 취한 경우 2, 1,0이다.

다시 몫을 4,9,16으로 곱해주면 8,9,0이다.
8은 4를 더하면 4의 배수중 가장 작은 수인 12가 되고
9는 9를 더하면 9의 배수중 가장 작은 수 18이 되고
0은 16을 더하면 16의 배수 중 가장 작은 단위가 된다.
즉 MIN을 각각의 제곱수로 나눈 후 올림을 하게되면
그 제곱수의 배수 중 가장 작은 수를 구할 수 있고 
그 수에서 MIN을 빼게 되면 각 제곱수의 배수가 시작하는 인덱스를 알 수 있따.

즉 12에서 10을 빼면 인덱스 2를 얻을 수 있음
18에서 10을 빼면 인덱스 8을 얻을 수 있음
16에서 10을 빼면 인덱스 6을 얻을 수 있음

현재 어디서 각 제곱수의 배수가 시작되는지 알았으므로, 해당 제곱수 만큼 계속 더해주고
범위 안에 있는 인덱스의 값을 모두 지워주면 된다.

16은 12를 기준으로 4칸, 20은 16을 기준으로 4칸을 더하여 갈 수 있다.
16의 경우 배열의 최대값이 23이기 때문에 16에 16을 더해줄 필요가 없고
18의 경우도 마찬가지다.

'''
import math
n,m = map(int,input().split())
arr = [1 for i in range(n,m+1)]

# square: 제곱수 
square = [i**2 for i in range(2,int(math.sqrt(m))+1) ]

for i in square:
    # idx : 처음 시작되는 인덱스
    idx = (math.ceil(n/i)*i) -n

    # 범위 만족시 지움
    while idx<=m-n:
        arr[idx] = 0 
        idx+=i
ans = 0 
for i in range(len(arr)):
    if arr[i] == 1:
        ans+=1
print(ans)
